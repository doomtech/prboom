<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="UltraEdit-32">
<title>Eternity Engine EDF Reference</title>
</head>

<body bgcolor="#CECECE">

<h2>Eternity Engine EDF Reference v1.2 -- 04/11/04</h2>

<a href="../etcengine.html">Return to the Eternity Engine Page</a>

<ul>
<li><a name="contents"><b>Table of Contents</b></a>
    <ul>
    <li><a href="#intro">Introduction to EDF</a>
    <li><a href="#changes">Changes in EDF 1.2</a>
    <li><a href="#gensyn">General Syntax</a>
    <li><a href="#files">Files</a>
        <ul>
        <li><a href="#whywad">Why Not in Wads?</a>
        <li><a href="#root">Specifying the Root EDF File</a>
        <li><a href="#inc">Including Files</a>
        <li><a href="#bex">Including BEX Files</a>
        <li><a href="#defs">Default EDF Files</a>
        <li><a href="#fallbacks">Default Fallbacks</a>
        <li><a href="#verbose">Verbose EDF Logging</a>
        </ul>
    <li><a href="#enables">Enable Functions</a>
    <li><a href="#sprnames">Sprite Names</a>
    <li><a href="#spritevars">Sprite-Related Variables</a>
    <li><a href="#pickups">Sprite-Based Pickup Items</a>
    <li><a href="#frames">Frames</a>
    <li><a href="#cmpframes">Compressed Frame Definitions</a>
    <li><a href="#things">Thing Types</a>
    <li><a href="#inherit">Thing Type Inheritance</a>
    <li><a href="#cast">DOOM II Cast Call</a>
    <li><a href="#boss">DOOM II Boss Brain Types</a>
    <li><a href="#sound">Sounds</a>
    <li><a href="#delta">Delta Structures</a>
    <li><a href="#misc">Miscellaneous Settings</a>
    </ul>
</ul>

<a name="intro">
<hr>
<b>Introduction to EDF</b>
<hr>
</a>
<br>
EDF, which stands for <b>Eternity Definition Files</b>, is a new data specification
language for the Eternity Engine that allows dynamic definition of sprites, thing types,
frames, and other previously internal data. The EDF parser is based on the libConfuse 
configuration file parser library by Martin Hedenfalk, which is also used by GFS and 
ExtraData.
<br><br>
EDF supercedes DeHackEd, and should become the preferred method for "exe" editing in the
future. However, EDF retains features that allow DeHackEd compatibility, and DeHackEd
patches may be loaded over EDF, and even have access to "new" things and frames that are
defined by it.
<br><br>
Each section in this document deals with one of the EDF constructs, as well as showing
their locations in the default EDF files. However, user-made EDF files can, with a few
caveats, contain these structures in any arrangement of files and in any order. User
EDF files do not need to use the same names or arrangements as the defaults, and they
should NEVER be intended to overwrite the Eternity Engine's default files, unless they
are being provided with a customized distribution of the engine itself.
<br><br>
Plans are in place to steadily introduce more features and functionality to EDF in 
future versions of the Eternity Engine, including most notably, weapon definitions.
This documentation will be regularly updated to reflect all changes and additions.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="changes">
<hr>
<b>Changes in EDF 1.2</b>
<hr>
</a>
<br>
<ul>
<li> Added enable functions for game mode control.
<li> Added inheritance mechanism for thing types.
<li> Added support for floating-point numbers in the thingtype fastspeed field.
<li> Added translation field for thing types.
<li> Added cflags, addflags, and remflags to the thingtype section.
<li> Changed error semantics for cast and boss spawner list.
<li> Added new section for miscellaneous settings.
</ul>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="gensyn">
<hr>
<b>General Syntax</b>
<hr>
</a>
<br>
<ul>
<li> EDF is Free-form
     <br><br>
     Whitespace and token positioning are totally free-form in EDF. In addition, semicolons
     are discarded as whitespace and can therefore be used to terminate field assignments, lists,
     etc. as in C or C++. As an example, all of the following are strictly equivalent:
     <pre>
     thingtype w00t { mass = 1000 }
     
     thingtype w00t
     {
        mass = 1000;
     }
     
     thingtype
                      w00t
                 {
        mass     =
             1000     ;;;;;;
                     }
     </pre>
     
     Obviously, you are encouraged to use a clean and consistent format, even though
     it is not required.
     <br><br>
     
<li> Comments
     <br><br>
     EDF files can use three forms of comments:
     <ul>
     <li> # Comments<br>
          Like in DeHackEd, this comment type extends to the end of the line.
     <li> // Comments<br>
          An alternate form of single-line comment, equivalent to #.
     <li> /* */ Comments<br>
          This type of comment is multiline, and extends from the opening /* to the first
          */ found. This type of comment CANNOT be nested. Nested multiline comments will
          cause a syntax error.          
     </ul>
     
     Examples:
     <pre>
     # Single line comment
     
     // Another single line comment
     
     /*
        This is a multiline comment
     */
     </pre>
<li> Strings
     <br><br>
     Many fields in EDF take strings. Strings, if they do not contain whitespace or any
     character that needs to be escaped, may be unquoted. Unquoted strings additionally
     cannot contain any of the following characters: " ' = { } ( ) + , # / ;<br>
     If any of those characters are found, the unquoted string will be terminated at the
     last valid character.<br><br>
     Example:
     <pre>
     spritenames += { SPR1, SPR2, SPR3 }
     </pre>
     The items SPR1, SPR2, and SPR3 are unquoted strings. Note how the commas serve to
     separate the items in a list, and therefore do not become part of the strings.
     <br><br>
     Other fields more or less require quoted strings. Quoted strings must start and end
     with either single or double quotes (the beginning and ending quote types must match,
     as well). Quoted strings may contain any character except a line break, including those 
     not allowed in unquoted strings. In addition, quoted strings also support the following 
     escape codes for non-typable characters:
     <br><br>
     <ul>
     <li> \n : Hard line break
     <li> \t : Tab
     <li> \b : Backspace
     <li> \a : Beep (causes a sound when printed to the console)
     <li> \\ : Literal \ character.
     <li> \" : Literal ", necessary to use in double-quoted strings only
     <li> \' : Literal ', necessary to use in single-quoted strings only
     </ul>
     <br><br>
     If \ is followed by any other character, the slash is discarded and the next character
     is treated normally (ie, \d becomes d).
     <br><br>
     Examples:
     <pre>
     thingtype w00t
     {
        obituary_normal = "w00ts"
        obituary_melee  = 'says \'w00t\''
     }
     </pre>
<li> Numbers
     <br><br>
     Most non-string fields in EDF are numbers, either integer or floating-point. Starting
     with EDF 1.1, decimal, octal, and hexadecimal integers will be accepted in all number
     fields. Octal numbers start with a zero, and hexadecimal numbers start with the 
     sequence 0x -- Examples:
     <pre>
     # this is a normal, decimal number
     spriteframe = 16
     ...
     # this is an octal number
     spriteframe = 020
     ...
     # this is a hexadecimal number
     spriteframe = 0x10</pre>
     
     Floating-point numbers must have a decimal point in them, as in 20.0 -- further
     documentation of the floating-point formats accepted will be available soon.
</ul>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="files">
<hr>
<b>Files</b>
<hr>
</a>
<br>
<a name="whywad">
<hr>
<b>Why Not in Wads?</b>
<hr>
</a>
<br>
Eternity cannot currently load EDF from wad lumps, although actions have been taken to
enable this in the near future.
<br><br>
In the meanwhile, Eternity offers several ways to make loading of EDF from files a gentler 
process. These are addressed in the <b>"Specifying the Root EDF File"</b> section 
below.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="root">
<hr>
<b>Specifying the Root EDF File</b>
<hr>
</a>
<br>
Eternity supports several methods for locating the root EDF file, which is the only EDF file
loaded directly for parsing.
<ul>
<li> Default -- root.edf
     <br><br>
     If no EDF file is specifically requested through any other method listed here, the engine 
     will load the file "root.edf" from its own directory. The default root.edf contains only
     include statements, which are covered in the next section.
     <br><br>
<li> Command-line Parameter -edf
     <br><br>
     The -edf command-line parameter allows the root EDF file to be specified explicitly, just
     like adding a WAD or DeHackEd file. The argument to the parameter should be exactly one
     complete relative or absolute file path, as in this example:
     <br><br>
     eternity -edf c:\blah\root.edf
     <br><br>
<li> Game File Script (GFS) Specification
     <br><br>
     The new GFS file can specify the root EDF file with the "edffile" keyword. Only one
     EDF file can be specified in a GFS. If -edf is used when a GFS is loaded, the command-line 
     parameter will take precedence. See the <a href="gfs_ref.html">GFS documentation</a> 
     for further information.     
</ul>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inc">
<hr>
<b>Including Files</b>
<hr>
</a>
<br>
Use of include files is critical for several purposes. First, it's unorganized and difficult
to maintain EDF files when everything is put haphazardly into one file. Second, through use
of the <b>stdinclude</b> function, user-provided EDF files can include the standard defaults,
without need to duplicate the data in them. This helps keep EDF files compatible with future
versions of the Eternity Engine, besides making your files much smaller.
<br><br>
To include a file normally, with a path relative to the current file doing the inclusion,
use the <b>include</b> function, like in these examples:
<pre>
# include examples

include("myfile.edf")
include("../prevdir.edf");  # remember, semicolons are purely optional
</pre>

This example would include "myfile.edf" from the same directory that the current file is
in, and "prevdir.edf" from the parent directory.
<br><br>
In order to remain compatible with future versions of Eternity, and to greatly reduce EDF
file sizes, you can include the standard, default EDF files into your own. To include files
relative to the Eternity executable's directory, use the <b>stdinclude</b> function, like
in this example:
<pre>
stdinclude("things.edf")
</pre>

This would include "things.edf" in the Eternity Engine's folder.
<br><br>
Include statements may only be located at the topmost level of an EDF file, and not inside
any section. The following example would not be valid:
<pre>
spritenames =
{
   include("sprnames.txt")
}
</pre>

Note that for maximum compatibility, you should limit EDF file names to MS-DOS 8.3 format 
and use only alphanumeric characters (ie, no spaces). This is not required for Windows or
Linux, but the DOS port of Eternity cannot use long file names.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inc">
<hr>
<b>Including BEX Files</b>
<hr>
</a>
<br>
As of Eternity Engine v3.31 public beta 5, EDF now supports including DeHackEd/BEX files.
Any DeHackEd/BEX files included will be queued in the order they are included, after any
other DeHackEd/BEX files to be processed.  DeHackEd/BEX processing occurs immediately
after EDF processing is complete.  This allows better cohesion between the EDF and BEX
languages, and also allows the user to specify fewer command line parameters or to avoid
the need for a GFS file in some cases.
<br><br>
To include a DeHackEd/BEX file for queueing from EDF, use the <b>bexinclude</b> function,
like in this example:
<pre>
bexinclude("strings.bex")
</pre>

The DeHackEd/BEX file will be included relative to the path of the including EDF file.
There is no <b>stdinclude</b> equivalent for DeHackEd/BEX files, since the engine does not
provide any default BEX files.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="defs">
<hr>
<b>Default EDF Files</b>
<hr>
</a>
<br>
This section explains the contents of each of the standard default EDF modules as of
Eternity Engine v3.31 public beta 4.
<ul>
<li> root.edf -- includes all other modules
<li> sprites.edf -- contains the sprite names list, and sprite-based pickup item definitions
<li> sounds.edf -- contains sound definitions
<li> frames.edf -- contains frame data for use by thing types and player guns
<li> things.edf -- contains thing type definitions
<li> cast.edf -- contains DOOM II cast call definitions
<li> misc.edf -- contains the default list of DOOM II Boss Spawner thing types
</ul>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="fallbacks">
<hr>
<b>Default Fallbacks</b>
<hr>
</a>
<br>
As a failsafe to allow old EDF modifications to continue working, EDF is now capable of
loading default modules individually when it determines there are zero definitions of certain
sections. The following modules will be loaded as fallbacks when the given conditions are met:
<ul>
<li> sprites.edf -- Loaded when zero sprite names are defined. Note that even if pickup items
     are defined by the user EDF, they will be overridden by the pickup items defined in
     sprites.edf.
<li> sounds.edf -- Loaded when zero sounds are defined.
<li> things.edf -- Loaded when zero thingtypes are defined.
<li> frames.edf -- Loaded when zero frames are defined.
<li> cast.edf -- Loaded when zero cast members are defined.
</ul>

Note that misc.edf cannot currently be used as a fallback. Also, this functionality is NOT
meant to allow users to neglect including the minimum required number of sections. This
functionality is only intended to preserve maximum backward compatibility with old EDF
modifications. Relying on fallback behavior in new EDFs may have unexpected results, including
possibly having your new definitions ignored.
<br><br>
If the engine-default EDF files cannot be found or parsed for any reason, EDF processing will 
cease immediately.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="verbose">
<hr>
<b>Verbose EDF Logging</b>
<hr>
</a>
<br>
Eternity includes a verbose logging feature in the EDF processor that allows a view of
more detailed information on what is occuring while EDF is being processed. This can help
nail down the location of any errors or omissions. To enable verbose EDF logging, use the
command-line parameter -edfout. This will cause Eternity to write an "edfout.txt" file in
its current working directory.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="enables">
<hr>
<b>Enable Functions</b>
<hr>
</a>
<br>
Starting with EDF 1.2, special functions are provided which allow the user to enable
or disable options within the EDF parser.  The primary use for these functions is to
instruct the parser to skip definitions for game modes other than the one currently
being played. Although all the thing, frame, sound, and sprite definitions will not
conflict and can be loaded with each other, most of the time this is unnecessary and requires
up a significant amount of memory which will never be used.  Allowing such definitions
to be discarded during parsing speeds up processing and reduces memory usage. Note that
all of these functions are only valid at the topmost level of an EDF file, and not within
definitions.
<br><br>
Enable Functions
<ul>
<li> <b>enable(&lt;option&gt;)</b>
     <br><br>
     This function enables the provided option from the point of its call onward.
     If the option is already enabled, no change takes place. If an invalid option
     name is provided, an error will occur.
     <br><br>
<li> <b>disable(&lt;option&gt;)</b>
     <br><br>
     This function disables the provided option from the point of its call onward.
     If the option is already disabled, no change takes place. If an invalid option
     name is provided, an error will occur.
     <br><br>
<li> <b>ifenabled(&lt;option&gt;)</b>
     <br><br>
     This function tests if the the provided option is enabled. If so, nothing will
     change. Otherwise, the EDF parser will be instructed to skip forward until it
     finds an <b>endif</b> function (see below). The <b>endif</b> function will then be 
     invoked. If the option provided is invalid, an error will occur. Note that 
     ifenabled/endif pairs cannot be nested.
     <br><br>
<li> <b>endif()</b>
     <br><br>
     This function marks the end of a section of the file started by an <b>ifenabled</b> call.
     When <b>ifenabled</b> tests an option which is not enabled, the parser will look for this
     function and then call it. This function will cause the parser to start recognizing
     definitions again from its line onward. If this function does not appear after an
     <b>ifenabled</b> before the end of the current file, a "missing conditional function" 
     error will occur.
</ul>

Available Options
<ul>
<li> <b>DOOM</b>
     <br><br>
     When this option is enabled, DOOM thing, frame, state, and sound definitions will
     be available. This variable is enabled by default for all user EDFs, but is disabled
     if the game is loaded in Heretic mode and the default root.edf file in Eternity's
     directory is loaded.
     <br><br>
<li> <b>HERETIC</b>
     <br><br>
     When this option is enabled, Heretic thing, frame, state, and sound definitions will
     be available. This variable is enabled by default for all user EDFs, but is disabled
     if the game is loaded in DOOM or DOOM II mode and the default root.edf in Eternity's
     directory is loaded.
</ul>

Notes on Game Mode Options:
<br><br>
As mentioned in their descriptions, the DOOM and HERETIC options will be enabled by
default when user EDF files are loaded. However, user EDF files can explicitly call the
<b>disable</b> function to turn off one or both options before including any of Eternity's
defaults. It is best to do this when you know you will not be using any of one of the
game modes' definitions.
<br><br>
Example:
<pre>
// this thing type is only available if HERETIC is enabled

ifenabled(HERETIC)

thingtype foo { spawnstate = S_FOO1 }

endif()
</pre>

Note on command-line option "-edfenables":

The -edfenables command-line option allows the user to override the default behavior
explicitly and enable all gamemode's definitions without adding an EDF file.  This does 
not interfere with explicit usage of enable functions, in user EDFs, but it does allow 
older DeHackEd patches and WADs which might assume Heretic definitions are available in 
DOOM or vice versa to work.
<br><br>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="sprnames">
<hr>
<b>Sprite Names</b>
<hr>
</a>
<br>
Sprite names are defined as a list of string values which must be exactly four characters
long, and should contain only capital letters and numbers.
<br><br>
Syntax:
<pre>
spritenames = { &lt;string&gt;, ... }
</pre>

If this syntax is used more than once, the definition which occurs last during parsing will
take precedence as the original definition of the sprite name list. Values may either be
added by copying the entire list in a new EDF file and adding the new values anywhere in the
list, or by using the following syntax:
<pre>
spritenames += { &lt;string&gt;, ... }
</pre>

This syntax allows the addition of new sprite names to the list without requiring the 
original list to be changed or copied.
<br><br>
The names defined in this list are the names by which a sprite must be referred to in all
other EDF structures. Sprites are the first item to be parsed, regardless of their location,
so like all EDF structures, the list and any additions to it can be placed anywhere.
<br><br>
Restrictions and Caveats:
<ul>
<li> There must be at least one sprite name defined.
<li> All sprite names used by other structures must be defined, or an error will occur.
<li> All sprite names must be unique.
<li> Sprite names will be checked for length and uniqueness, but not for invalid characters.
<li> If compatibility with DeHackEd patches is desired, new sprites should use addition lists.
</ul>
Full example:
<pre>
# defining an original spritenames array (this would replace the default list)
# notice that sprite names never NEED to be quoted, but can be if so desired.
spritenames =
{
   FOO1, FOO2, FOO3, TNT1, PLAY
}

# add a few values in later (maybe near a thing or frames that use them)...
spritenames += { "BLAH" }
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="spritevars">
<hr>
<b>Sprite-Related Variables</b>
<hr>
</a>
<br>
There are two sprite-related variables which may be specified in user EDF files:
<ul>
<li> <b>playersprite</b>
<li> <b>blanksprite</b>
</ul>

<b>playersprite</b> sets the sprite to be used by the default "Marine" player skin. This
must be one of the four-character sprite mnemonics defined in the <b>spritenames</b> array.
If not provided in any EDF file, this variable defaults to the value "PLAY" (and if
PLAY is not defined in that case, an error will occur).
<br><br>
<b>blanksprite</b> sets the sprite to be used when objects or guns attempt to use a sprite
which has no graphics loaded. This must be one of the four-character sprite mnemonics
defined in the <b>spritenames</b> array. If not provided in any EDF file, this variable defaults
to the value "TNT1" (and if TNT1 is not defined in that case, an error will occur).
<br><br>
These values are parsed immediately after the sprite name list is loaded, and can be
placed anywhere. If defined more than once, the last definition encountered takes
precedence. These values must be defined at the topmost level of an EDF file.
<br><br>
Syntax:
<pre>
playersprite = &lt;sprite mnemonic&gt;

blanksprite = &lt;sprite mnemonic&gt;
</pre>

Full example:
<pre>
# set the player skin sprite to BLAH
playersprite = BLAH

# set the blank sprite to FOO1
blanksprite = FOO1
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="pickups">
<hr>
<b>Sprite-Based Pickup Items</b>
<hr>
</a>
<br>
Sprite-based pickup item definitions allow one of a set of predefined pickup effects to be
associated with a sprite, so that collectable objects (with the SPECIAL flag set) using it
will have that effect on the collecting player.
<br><br>
It is currently only possible to associate one effect with a given sprite, but effects can
be assigned to as many sprites as is desired. If a sprite is assigned more than one pickup
effect, the one occuring last takes precedence. There are plans to extend this feature in 
the future to include customizable pickup items, but for now only the predefined effects are
available.
<br><br>
Syntax:
<pre>
pickupitem &lt;sprite mnemonic&gt; { effect = &lt;effect name&gt; }
</pre>

<b>sprite mnemonic</b> must be a valid sprite mnemonic defined in the <b>spritenames</b> list.<br>
<b>effect name</b> may be any one of the following:
<pre>
   ** Note: all ammo amounts double in "I'm Too Young To Die" and "Nightmare!"
   ** Note: weapons give 5 clips of ammo when "Weapons Stay" DM flag is on
   ** Note: dropped weapons give half normal ammo
   
   Effect Name         Item is...               Special effects
  ----------------------------------------------------------------------------
   PFX_NONE            No-op collectable        None
   PFX_GREENARMOR      Green armor jacket       +100% armor
   PFX_BLUEARMOR       Blue armor jacket        +200% armor
   PFX_POTION          DOOM health potion       +1% health
   PFX_ARMORBONUS      Armor bonus              +1% armor
   PFX_SOULSPHERE      Soulsphere               +100% health
   PFX_MEGASPHERE      Megasphere               200% health/armor
   PFX_BLUEKEY         DOOM Blue key card
   PFX_YELLOWKEY       DOOM Yellow key card
   PFX_REDKEY          DOOM Red key card
   PFX_BLUESKULL       DOOM Blue skull key
   PFX_YELLOWSKULL     DOOM Yellow skull key
   PFX_REDSKULL        DOOM Red skull key
   PFX_STIMPACK        Stimpack                 +10% health
   PFX_MEDIKIT         Medikit                  +25% health
   PFX_INVULNSPHERE    Invulnerability Sphere   Temporary god mode
   PFX_BERZERKBOX      Berzerk Box              Super strength
   PFX_INVISISPHERE    Invisibility Sphere      Temporary partial invis.
   PFX_RADSUIT         Radiation Suit           No nukage damage
   PFX_ALLMAP          Computer Map             All of automap revealed
   PFX_LIGHTAMP        Light Amp Visor          All lights at full level
   PFX_CLIP            Clip                     +10 Bullets
   PFX_CLIPBOX         Clip box                 +50 Bullets
   PFX_ROCKET          Rocket                   +1 Rocket
   PFX_ROCKETBOX       Box of Rockets           +10 Rockets
   PFX_CELL            Cells                    +20 Cells
   PFX_CELLPACK        Cell pack                +100 Cells
   PFX_SHELL           Shells                   +4 Shells
   PFX_SHELLBOX        Box of Shells            +20 Shells
   PFX_BACKPACK        Backpack                 Max ammo *= 2, +1 clip all ammo
   PFX_BFG             BFG                      BFG weapon, +2 clips cells
   PFX_CHAINGUN        Chaingun                 Chaingun weapon, +2 clips bull.
   PFX_CHAINSAW        Chainsaw                 Chainsaw weapon
   PFX_LAUNCHER        Rocket launcher          Rocket launcher weapon, +2 rock.
   PFX_PLASMA          Plasma Gun               Plasma gun weapon, +2 clips cells
   PFX_SHOTGUN         Shotgun                  Shotgun weapon, +2 clips shells
   PFX_SSG             Super Shotgun            SSG weapon, +2 clips shells
   PFX_HGREENKEY       Heretic Green key        ** Gives both DOOM red keys
   PFX_HBLUEKEY        Heretic Blue key         ** Gives both DOOM blue keys
   PFX_HYELLOWKEY      Heretic Yellow key       ** Gives both DOOM yellow keys
   PFX_HPOTION         Heretic Potion           +10% health
   PFX_SILVERSHIELD    Silver Shield            +100% Heretic armor (stronger)
   PFX_ENCHANTEDSHIELD Enchanted Shield         +200% Heretic armor (stronger)
   PFX_BAGOFHOLDING    Bag of Holding           No effect yet
   PFX_HMAP            Map Scroll               All of automap revealed
   PFX_TOTALINVIS      Total InvisiSphere       Temporary total invisibility
  -----------------------------------------------------------------------------
</pre>

Full example:
<pre>
# define a couple of sprite-based pickups
pickupitem FOO2 { effect = PFX_TOTALINVIS }
pickupitem FOO3 { effect = PFX_LAUNCHER }

# redefine an existing pickup effect (don't forget free-form syntax...)
pickupitem FOO3 
{ 
   effect = PFX_ENCHANTEDSHIELD;
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="frames">
<hr>
<b>Frames</b>
<hr>
</a>
<br>
Frames, also known as states, define the animation and logic sequences for thing types and
player weapons.
<br><br>
Each frame must be given a unique mnemonic in its definition's header, and this is the name
used to identify the frame elsewhere. Each field in the frame definition is optional. If a 
field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
If a frame's mnemonic is not unique, the latest definition of a frame with that mnemonic
replaces any earlier ones. As of EDF 1.1 (Eternity Engine v3.31 public beta 4), frame 
mnemonics are completely case-insensitive. This means that a frame defined with a mnemonic 
that differs from an existing one only by case of letters will overwrite the original frame.
<br><br>
Note that the order of frame definitions in EDF is not important. For purposes of DeHackEd,
the number used to access a frame is now defined in the frame itself. For the original frames,
these happen to be the same as their order.
<br><br>
User frames that need to be accessible from DeHackEd can define a <b>unique</b> DeHackEd
number, which for purposes of forward compatibility, should be greater than or equal to 10000,
and less than 32768. User frames not needing access via DeHackEd can be given a DeHackEd 
number of -1. This causes them to be inaccessible to DeHackEd.
<br><br>
Syntax:
<pre>
# Remember that all fields are optional and can be in any order.

frame &lt;unique mnemonic&gt;
{
   sprite         = &lt;sprite mnemonic&gt;
   spriteframe    = &lt;number&gt; OR &lt;character&gt;
   fullbright     = &lt;boolean&gt;
   tics           = &lt;number&gt;
   action         = &lt;bex codeptr name&gt;
   nextframe      = &lt;frame mnemonic&gt; OR &lt;nextframe specifier&gt;
   misc1          = &lt;special field&gt;
   misc2          = &lt;special field&gt;
   particle_event = &lt;event name&gt;
   args           = { &lt;special field&gt;, ... }
   dehackednum    = &lt;unique number&gt;
   cmp            = &lt;compressed frame definition&gt;
}
</pre>

Explanation of fields:
<ul>
<li><b>sprite</b><br>
    Default = "BLANK" (this special value can be used to access the blanksprite value)<br>
    Sets the sprite displayed when this frame is used. Must be a sprite mnemonic defined in
    the <b>spritenames</b> list, or the special value "BLANK".
<li><b>spriteframe</b><br>
    Default = 0<br>
    Sets the frame of the sprite displayed. A frame value of 0 displays the graphic that is
    named with an A in wads, 1 displays B, and so forth. Starting with EDF 1.1, you may also
    specify a character from A to ], matching the lump name.<br>
    Examples:
    <pre>
    # These are equivalent
    spriteframe = 0
    ....
    spriteframe = A</pre>
<li><b>fullbright</b><br>
    Default = false<br>
    Determines if this frame renders a sprite at fullbright light level. Can be set to any
    of the values yes/no, on/off, or true/false, with the obvious meanings.
<li><b>tics</b><br>
    Default = 1<br>
    Determines the length of time an object remains in this frame. A tic is equivalent to
    1/35th of a second, so 35 tics is 1 second. A frame with 0 tics is passed through
    instantly. A frame with -1 tics is stayed in forever (see nextframe below).
<li><b>action</b><br>
    Default = "NULL"<br>
    Sets the action to be taken when this frame is entered. This is also known as the
    codepointer, and uses the same mnemonics that are used in the 
    <a href="dehref.html#codeptr">BEX Codepointer block</a>. Also see the
    <a href="codeptrs.html">Eternity Engine Definitive Codepointer Reference</a>
    for detailed information on what every available codepointer does.
<li><b>nextframe</b><br>
    Default = S_NULL<br>
    Sets the frame to which the object will transfer when this one has been passed. Note
    that if the frame's tics value is -1, this field will never be used. This field must be
    a valid frame mnemonic. It can be the name of the same or any other frame.<br>
    Starting with EDF 1.1, you may also specify one of several special reserved words for
    this field:
    <ul>
    <li><b>@next</b> -- sets nextframe to the next frame defined in EDF
    <li><b>@prev</b> -- sets nextframe to the previous frame defined in EDF
    <li><b>@this</b> -- sets nextframe to the same frame (the one being processed)
    <li><b>@null</b> -- sets nextframe to the S_NULL frame
    </ul>
    <br>
    Note that if @next or @prev are used for the last or first frames respectively, an error
    will occur.
<li><b>misc1</b><br>
    Default = "0"<br>
    This is a special field which can accept a wide range of special value types. See the
    information below on special fields.
<li><b>misc2</b><br>
    Default = "0"<br>
    This is a special field which can accept a wide range of special value types. See the
    information below on special fields.
<li><b>particle_event</b><br>
    Default = pevt_none<br>
    This field lists the name of a particle event that will be triggered by an object when
    it enters this frame. Valid particle event names are as follows:
    <pre>
    Effect name           Effect
    --------------------------------------
    pevt_none             No effect
    pevt_rexpl            Rocket Burst
    pevt_bfgexpl          BFG Burst
    </pre>
<li><b>args</b><br>
    Default = All values will be set to 0<br>
    This list will accept up to five special values. If more than five are provided, only
    the first five will be used. If less than 5 are provided, any not provided are set to
    zero. This list corresponds to the DeHackEd fields Args1 through Args5, in order. The
    purpose of this list is to serve as a set of arguments to parameterized codepointers.
    See the information on special fields below.
<li><b>dehackednum</b><br>
    Default = -1<br>
    As explained above, this is the number which must be used to refer to this frame in
    DeHackEd patches. -1 means that the frame is not accessible from DeHackEd, or by parameterized
    codepointers that require a frame DeHackEd number. User-defined frames should currently 
    only use DeHackEd numbers between 10000 and 32768, or simply use -1 if no DeHackEd 
    functionality is required. This number must be unique unless it is -1.
<li><b>cmp</b><br>
    Default = none<br>
    The cmp field is used to provide a compressed definition for the normal fields of this
    frame. When the cmp field is provided, all other fields except dehackednum will be
    ignored. See the <a href="#cmpframes">Compressed Frame Definitions</a> section below
    for full information. Note that this field is NOT accepted inside framedelta blocks.
    This field is new to EDF 1.1.
</ul>

Special Fields:
<br><br>
The special fields misc1 and misc2, as well as all five usable values of the args list, can
take special values of the following type by using prefix:value syntax as shown:
<ul>
<li><b>frame:&lt;frame mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated frame. If the indicated frame has
     no unique DeHackEd number, the S_NULL state will be stored and a warning will be issued
     to the verbose EDF log.<br>
     Example:
     <pre>
     misc1 = frame:S_FOOBAR1
     </pre>
<li><b>thing:&lt;thing mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated thing type. If the indicated thing has
     no unique DeHackEd number, the Unknown thing type will be stored and a warning will be issued
     to the verbose EDF log.<br>
     Example:
     <pre>
     misc1 = thing:BaronOfHell
     </pre>
<li><b>sound:&lt;sound mnemonic&gt;</b><br>
     Translated to the DeHackEd number of the indicated sound. See the 
     <a href="dehref.html#sndtable">Internal Sound List</a> 
     in the Eternity DeHackEd/BEX Reference for a list of documented sound mnemonics,
     or view the default sounds.edf file. If the indicated sound has no unique DeHackEd
     number, the dummy sound "none" will be stored and a warning will be issued to the verbose
     EDF log.<br>
     Example:
     <pre>
     misc2 = sound:pistol
     </pre>
<li><b>flags:&lt;flag list&gt;</b>
<li><b>flags2:&lt;flag list&gt;</b>
<li><b>flags3:&lt;flag list&gt;</b><br>
    Translated into the corresponding integer value for the appropriate thing
    flags field (needed for some parameterized codepointers). See the
    <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the
    Eternity DeHackEd/BEX Reference for full information. The format here is the same
    with the exception that if white space or restricted characters are put into a flag 
    list, the entire special field value MUST be enclosed in quotation marks.<br>
    Examples:
    <pre>
    args = { 1, flags:SOLID|SHOOTABLE|COUNTKILL }
    
    # this needs quotations here, whereas it doesn't in a BEX file, because both
    # whitespace and + characters aren't allowed in unquoted strings in EDF
    
    misc2 = "flags2:LOGRAV + BOSS"
    </pre>
<li><b>bexptr:&lt;codepointer mnemonic&gt;</b><br>
    Translated into an internal codepointer table index. Used by parameterized codepointers
    that request another codepointer which they will call directly, such as PlayerThunk. The
    values to which codepointer mnemonics are translated are *not* published, and could
    change from version to version. Therefore, you *must* use EDF for these types of
    codepointers.<br>
    Example:
    <pre>
    args = { bexptr:Chase }
    </pre>
<li><b>No Prefix</b><br>
    If no prefix is given for a value, it is interpreted as an integer number via the
    C function "strtol".<br>
    Examples:
    <pre>
    misc1 = 32768
    misc2 = -45
    args = { 1, 1, 2, 3, 5 }
    </pre>
<li><b>Invalid prefixes</b><br>
    If any prefix is used other than the ones listed here, an error will occur.
</ul>

Restrictions and Caveats:
<ul>
<li> At least one frame must be defined.
<li> The S_NULL frame must be defined (it may be the only frame, but it must exist).
<li> All frames must have a unique mnemonic no longer than 40 characters. Frame mnemonics are
     currently case-insensitive. They should only contain alphanumeric characters and 
     underscores. All other punctuation marks are explicity reserved for extended syntactical
     use. Length will be verified, but format will not (non-unique mnemonics will  overwrite 
     previous definitions, see below).
<li> All frames with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     This will be verified.
</ul>

Replacing Existing Frames:
<br><br>
To replace the values of an existing frame, simply define a new frame with the exact same
mnemonic value (as stated above, all frames need a unique mnemonic, so duplicate mnemonics
serve to indicate that an existing frame should be replaced).

EDF 1.1 also adds delta structures, which allow fields of existing frames to be edited
without replacing all values in those frames. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# define some new frames
frame BLAH1
{
   sprite = FOO1
   fullbright = true
   tics = 12
   nextframe = BLAH2
}

frame BLAH2
{
   sprite = FOO1
   tics = 12
   nextframe = BLAH1
}

# Overwrite an existing frame (since BLAH1 is already defined above...)
# Also remember that mnemonics are case-insensitive!
frame blah1
{
   sprite = FOO1
   fullbright = true
   tics = 12
   action = HticExplode
   args = { 1 }
   nextframe = S_NULL
}
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="cmpframes">
<hr>
<b>Compressed Frame Definitions</b>
<hr>
</a>
<br>
Compressed frame definitions are a new feature in EDF 1.1 that allows a shorthand syntax for
specifying the fields of a frame block.
<br><br>
A compressed frame definition resides inside a normal EDF frame definition, using the
<b>cmp</b> keyword outlined in the syntax of the <b><a href="#frames">frame</a></b> block.
It accepts a single string value with an extended syntax, and the value of all other fields
in the frame block except for the <b>dehackednum</b> can be set via this string.  When the cmp
field is present in a frame block, all other fields except <b>dehackednum</b> are ignored.
<br><br>
Note that the <b>cmp</b> field is NOT accepted inside framedelta blocks.
<br><br>
Syntax:
<pre>
frame
{
   cmp = &lt;compressed frame definition&gt;
}
</pre>

The compressed frame definition string has the following syntax:

<pre>
"sprite|spriteframe|fullbright|tics|action|nextframe|particle_event|misc1|misc2|args1-5"
</pre>

Fields *MUST* be provided in the order given, but any number of fields can be left off at
the end of the definition, and those fields will receive their normal default values. To
let an internal field default, you must use the special reserved value "*" for that field.
<br><br>
Each field is delimited by pipe characters, and field values may NOT contain pipe characters.
This means that if a misc or args value must specify a BEX flag string, you must use a plus
sign, comma, or whitespace to separate the flags, NOT a pipe. Extraneous whitespace is NOT
allowed between field delimiters and their values. Any whitespace between two pipes will be
interpreted as being part of that field's value.
<br><br>
The fullbright field has a special caveat within compressed frame definitions. The values T or
t will be accepted to mean true, and any other value, including the default, will be interpreted
to mean false.
<br><br>
Otherwise, all fields can accept exactly the same types and ranges of values that they
normally accept when specified separately within a frame block. This includes letters and
numbers for the spriteframe field, special keywords for the nextframe field, and prefix:value
syntax for misc1, misc2, and the five args fields.
<br><br>
Examples:
<pre>
# this is a compressed frame definition which specifies ALL the values

frame FOOBAR1 { cmp = "AAAA|A|F|6|Look|@next|pevt_none|0|0|0|0|0|0|0" }

# this is an equivalent frame definition, using default specifiers and
# leaving off defaulting fields at the end of the definition. This frame
# and the above mean the EXACT same thing.

frame FOOBAR1 { cmp = "AAAA|*|*|6|Look|@next" }

# here is a complicated example using a parameterized codepointer

#                                                          Args start here
#                                                          |
#                                                          V
frame FOOBAR2 { cmp = "TROO|6|*|6|MissileAttack|@next|*|*|*|thing:DoomImpShot|*|*|20" }
</pre>

Some illegal compressed frame definitions would include the following. Don't make these
mistakes:
<pre>

# This is wrong, field values may NOT be empty -- use "*" to indicate a default.

frame BAD1 { cmp = "AAAA|||6|Look|@next" }

# This is wrong because extraneous whitespace will be interpreted as part of the
# fields' values. 

frame BAD2 { cmp = "AAAA | B | T | 23 | Chase | BAD3" }

# This is wrong because BEX flag fields CANNOT use | inside compressed frames.

frame BAD3 { cmp = "AAAA|B|T|23|SomePointer|*|*|*|flags:SOLID|SHOOTABLE|COUNTKILL" }

# This is wrong because you cannot leave off fields at the beginning.

frame BAD4 { cmp = "Look|@next" }

# This is wrong because fields must be in the correct order.

frame BAD5 { cmp = "6|TROO|*|6|thing:DoomImp|@next|MissileAttack|*|20" }
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="things">
<hr>
<b>Thing Types</b>
<hr>
</a>
<br>
Thing types define monsters, lamps, control points, items, etc -- anything that moves, occupies
space, can display a sprite, or is useful for singling out locations.
<br><br>
Each thing type must be given a unique mnemonic in its definition's header, and this is the name
used to identify the thing type elsewhere. Each field in the thing type definition is optional. 
If a field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
If a thing type's mnemonic is not unique, the latest definition of a thing type with that mnemonic
replaces any earlier ones. See the information below for more on this. As of EDF 1.1 
(Eternity Engine v3.31 public beta 4), thing type mnemonics are completely case-insensitive. This 
means that a thing type defined with a mnemonic that differs from an existing one only by case of 
letters will overwrite the original type.
<br><br>
Note that the order of thing type definitions in EDF is not important. For purposes of DeHackEd,
the number used to access a thing type is now defined in the type itself. For the original
thing types, these happen to be the same as their order.
<br><br>
User thing types that need to be accessible from DeHackEd can define a <b>unique</b> DeHackEd
number, which for purposes of forward compatibility, should be greater than or equal to 10000 
and less than 32768. User types not needing access via DeHackEd can be given a DeHackEd 
number of -1. This causes them to be inaccessible to DeHackEd and to parameterized codepointers.
<br><br>
Syntax:
<pre>
# Remember that all fields are optional and can be in any order.

thingtype &lt;unique mnemonic&gt;
{
   inherits        = &lt;thing type mnemonic&gt;
   doomednum       = &lt;number&gt;
   spawnstate      = &lt;frame mnemonic&gt;
   spawnhealth     = &lt;number&gt;
   seestate        = &lt;frame mnemonic&gt;
   seesound        = &lt;sound mnemonic&gt;
   reactiontime    = &lt;number&gt;
   attacksound     = &lt;sound mnemonic&gt;
   painstate       = &lt;frame mnemonic&gt;
   painchance      = &lt;number&gt;
   painsound       = &lt;sound mnemonic&gt;
   meleestate      = &lt;frame mnemonic&gt;
   missilestate    = &lt;frame mnemonic&gt;
   deathstate      = &lt;frame mnemonic&gt;
   xdeathstate     = &lt;frame mnemonic&gt;
   deathsound      = &lt;sound mnemonic&gt;
   speed           = &lt;number&gt; OR &lt;floating-point number&gt;
   radius          = &lt;floating-point number&gt;
   height          = &lt;floating-point number&gt;
   mass            = &lt;number&gt;
   damage          = &lt;number&gt;
   activesound     = &lt;sound mnemonic&gt;
   flags           = &lt;flag list&gt;
   flags2          = &lt;flag list&gt;
   flags3          = &lt;flag list&gt;
   cflags          = &lt;flag list&gt;
   addflags        = &lt;flag list&gt;
   remflags        = &lt;flag list&gt;
   raisestate      = &lt;frame mnemonic&gt;
   translucency    = &lt;number&gt;
   bloodcolor      = &lt;number&gt;
   fastspeed       = &lt;number&gt; OR &lt;floating-point number&gt;
   nukespecial     = &lt;BEX codepointer mnemonic&gt;
   particlefx      = &lt;particle effect flag list&gt;
   droptype        = &lt;thing type mnemonic&gt;
   mod             = &lt;number&gt;
   obituary_normal = &lt;string&gt;
   obituary_melee  = &lt;string&gt;
   translation     = &lt;number&gt; OR &lt;translation table lump name&gt;
   dehackednum     = &lt;unique number&gt;
}
</pre>

Explanation of fields:
<ul>
<li><b>inherits</b><br>
    No default value<br>
    Sets the thing type from which this type will inherit values. See the
    <a href="#inherit">Thing Type Inheritance</a> section below for full information on how
    thing type inheritance works.    
<li><b>doomednum</b><br>
    Default = -1<br>
    Sets the ID used to identify this thing type in maps. For example, when a map calls for a 
    thing with ID 2003, the game engine will find the thing type which has that number in this 
    field. Every thing that will be spawned on maps must have a unique doomednum. Things which 
    are not spawned on maps, such as fireballs, can be given the default doomednum of -1.<br>
    For purposes of forward compatibility, user-defined thing types should use doomednums
    greater than or equal to 20000 and less than 32768. All other doomednum ranges are considered
    to be reserved as outlined here. The purposes of various blocks may be relaxed in the
    future for purposes of internal use, so these are only rough guidelines provided for
    completeness.
    <pre>
     Doomednum Range     Usage
    ---------------------------------------------------------------
        0                No-op, no thing will be spawned at all
        1 -  4999        Original DOOM things and some extensions
     5000 -  5999        BOOM-style control points
     6000 -  6999        Reserved for port use
     7000 -  7999        Things translated from other games
     8000 -  8999        Reserved for port use
     9000 -  9999        zdoom-style control points
    10000 - 19999        Reserved for port use
    20000 - 32767        Reserved for EDF</pre>
<li><b>spawnstate</b><br>
    Default = S_NULL<br>
    Sets the frame which a thing starts in when it is spawned. Monsters generally use this 
    frame to stand still and look for targets.
<li><b>spawnhealth</b><br>
    Default = 1000<br>
    Sets a thing's maximum amount of life. It is only used for things which can be shot.
<li><b>seestate</b><br>
    Default = S_NULL<br>
    Sets the frame which a monster will jump to when it sees or hears a target. 
    Also called walking frames, or first moving frame. 
<li><b>seesound</b><br>
    Default = none<br>
    Sets the sound that a monster will play when it awakens. This sound is also played by 
    missiles when they are shot. (Note: "none" is a special mnemonic for no sound)
<li><b>reactiontime</b><br>
    Default = 8<br>
    Sets an amount of time that a thing must wait under certain circumstances. Monsters use 
    this value as a means to control their rate of attack. This value is also used as an 
    internal field for varying purposes, but those uses are not editable.
<li><b>attacksound</b><br>
    Default = none<br>
    Sets a sound used by some monster attacks, including the Lost Soul's charge.
<li><b>painstate</b><br>
    Default = S_NULL<br>
    Sets the frame a thing may randomly enter when it has been injured.
<li><b>painchance</b><br>
    Default = 0<br>
    Sets the chance out of 255 that this thing will enter its painstate when it is injured. 
    A thing with 0 painchance will never feel pain, whereas a thing with 255 painchance will 
    always feel pain. If a thing has a painchance greater than zero, it should have a valid 
    painstate, otherwise it will disappear forever. 
<li><b>painsound</b><br>
    Default = none<br>
    Sets the sound played by the Pain codepointer when this thing uses it. Monsters and the 
    player always call Pain from their painstate.
<li><b>meleestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, monsters chasing a target will attempt to close to melee 
    range quickly. When they determine they are within 64 units of their target, they may 
    randomly enter this frame to perform a melee attack.
<li><b>missilestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, monsters chasing a target will randomly enter it to perform 
    a missile attack.
<li><b>deathstate</b><br>
    Default = S_NULL<br>
    When a thing dies normally, it will enter this state. If the state is S_NULL, the thing 
    will disappear forever.
<li><b>xdeathstate</b><br>
    Default = S_NULL<br>
    If a thing dies by taking enough damage that its health is equal to its negated spawnhealth 
    value, it will enter this frame instead of its deathstate. This is also known as gibbing, or 
    extreme death. If this frame is S_NULL, the thing will always die normally.
<li><b>deathsound</b><br>
    Default = none<br>
    Sound played by the Scream codepointer. Used to play monster death sounds.
<li><b>speed</b><br>
    Default = 0<br>
    Value used by monsters as a movement delta per walking frame. The monster will move by an 
    amount relative to this value each time it uses the Chase codepointer. For missiles, this 
    value is a fixed-point number (multiplied by 65536), and represents a constant speed by 
    which the missile advances every game tic. Missile speed is not affected by the missile 
    frame durations, whereas monster walking speed is.<br>
    Starting with EDF 1.1, this field also supports floating-point values. When a floating-point
    value is provided, it will be translated into the corresponding fixed-point value. This
    means that a value of 10.0 is equivalent to the integer value 655360 (10*65536). It is NOT
    equivalent to 10. This distinction is very important. Small integer speed values are
    appropriate for monsters, whereas floating-point values will be suitable only for missiles.
<li><b>radius</b><br>
    Default = 20.0<br>
    Floating-point value that represents the radius of this thing type. A thing can fit into 
    corridors which are at least as wide as this value times two, plus one unit (ie a thing 
    with radius 32 can fit into a 65-wide hallway). The maximum value this field *should* 
    have is 32.0 units. However, the game breaks its own rule here, giving several monsters 
    radii up to 128 units. These monsters, which include the mancubus, arachnotron, and spider 
    demon, exhibit clipping errors which enable other things to walk into them, and which can 
    cause some moving sectors to malfunction. Avoid giving things radii larger than this to 
    remain absolutely safe.
<li><b>height</b><br>
    Default = 16.0<br>
    Floating-point value that represents the height of this thing type. A thing can fit into 
    areas which are of this exact height or taller. Note that in DOOM, this value is only used 
    to see where a monster can fit relative to walls and floor/ceiling heights. For purposes of 
    clipping against other things, monsters were considered to be infinitely tall. However, 
    Eternity's extended 3D object clipping enables this field to also be used to allow or 
    disallow things to pass over, under, or stand on this thing.
<li><b>mass</b><br>
    Default = 100<br>
    Normal integer value that serves as a mass factor for this object. Mass affects the amount 
    of thrust an object is given when it is damaged, the amount of effect an archvile's attack 
    can have on it, and for bouncing objects, the rate at which they fall.
<li><b>damage</b><br>
    Default = 0<br>
    This number is used as a damage multiplier when a missile hits a thing. 
    The damage formula used is: 
    <pre>
        damage = ((rnd % 8) + 1) * missiledamage
    </pre>
    
    This field is also used as a parameter by some new, parameterized codepointers, including 
    BetaSkullAttack and Detonate.
<li><b>activesound</b><br>
    Default = none<br>
    Sets the sound used by a thing when it is wandering around. A thing is given a 3 out of 
    256 chance (1.17%) of making this sound every time it calls the Chase codepointer. There 
    are some new flags3 flags which can alter the behavior of this sound.
<li><b>flags</b><br>
    Default = ""<br>
    This field controls a number of thing type properties using bit flags, where each bit in 
    the field stands for some effect, and has the value of being either on or off. 
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits">Bits Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>flags2</b><br>
    Default = ""<br>
    Similar to flags but takes a different set of values with different meanings. 
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits2">Bits2 Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>flags3</b><br>
    Default = ""<br>
    Similar to flags, but takes a different set of values with different meanings.
    See the <a href="dehref.html#tngflags">Thing Flag List</a> documentation in the Eternity
    DeHackEd/BEX Reference, and also see the <a href="dehref.html#tngbits3">Bits3 Mnemonics</a> 
    section for the values which can be used in this field. Remember that if whitespace or
    disallowed characters are used, this field's value must be enclosed in quotation marks.
<li><b>cflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field allows specification of all the thing's flag values in one
    single flag list. When this field is defined, the 3 normal flags fields above are ignored.
    You can use one or the other in any definition, but not both in the same definition. The
    only caveat to this field is that the flags bit "SLIDE", which has no effect, cannot be
    specified in this field. If SLIDE is used, it will activate the flags3 bit with the same
    name, which has the expected effect. All other flags will be assigned to their appropriate
    internal fields as normal. See the DeHackEd documentation listed in the fields above for
    full information on flag list format and flag mnemonics.
<li><b>addflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field specifies a combined list of flags to be added to the thing's
    existing flags values (this works the same as the <b>cflags</b> field above). Flags in this
    list are "turned on" in the thing. If flags are listed here which are already "on," there
    is no effect. This field is most useful within <b>thingdelta</b> sections and in concert
    with thing type inheritance.
<li><b>remflags</b><br>
    Default = ""<br>
    New to EDF 1.2, this field specifies a combined list of flags to be subtracted from the
    thing's existing flags values (this works the same as the <b>cflags</b> field above). Flags
    in this list are "turned off" in the thing, as if they had never been listed. If flags
    are listed here which are not already "on," there is no effect. This field is most useful
    within <b>thingdelta</b> sections and in concert with thing type inheritance. This field
    will be applied *AFTER* the addflags field is applied, so it could potentially turn off
    flags turned on by that field.
<li><b>raisestate</b><br>
    Default = S_NULL<br>
    If this frame is not S_NULL, an Archvile can perform a resurrection on this creature. When 
    this occurs, the creature will enter this frame.
<li><b>translucency</b><br>
    Default = 65536<br>
    This field allows fine, customizable control over a thing's translucency. The value of this 
    field may range from 0 to 65536, with 0 being completely invisible, and 65536 being normal. 
    Note this effect is mutually exclusive of BOOM-style translucency. If this value is not 
    65536, and the BOOM translucency flag is turned on, the flag will be turned off at run-time, 
    and this field will take precedence.
<li><b>bloodcolor</b><br>
    Default = 0<br>
    Allows this thing type to have differently colored blood when particle blood effects are 
    enabled (this does not currently have any effect on blood sprites). Currently available 
    blood color values are as follows:
    <pre>
     Blood color       Number
    --------------------------
     Red (normal)        0
     Grey                1
     Green               2
     Blue                3
     Yellow              4
     Black               5
     Purple              6
     White               7
     Orange              8
    --------------------------
    </pre>
<li><b>fastspeed</b><br>
    Default = 0<br>
    When the game is switched into Nightmare difficulty or -fast mode is active, all thing
    types with a non-zero fastspeed will have their speed fields changed to their fastspeed
    value. This enables editing of the -fast speed of projectiles and monsters. For detailed
    information on speed, see the speed field itself above. Note: as of EDF 1.2, this field
    also supports floating-point numbers, with the same meaning as that for the speed field.
<li><b>nukespecial</b><br>
    Default = S_NULL<br>
    This field is the name of a special codepointer to call when the player uses the KILLEM
    cheat to kill all monsters. Currently only two special pointers are provided for this
    purpose, PainNukeSpec and SorcNukeSpec. These enable monsters with spawn-on-death actions
    to either spawn enemies early, or not at all. See the
    <a href="codeptrs.html">Eternity Engine Definitive Codepointer Reference</a>
    for detailed information.
<li><b>particlefx</b><br>
    Default = 0<br>
    This field is a flag field with syntax identical to the flags, flags2, and flags3 fields,
    but which accepts the following values which control what persistent particle effects are
    associated with objects of this type:
    <pre>
     Flag name       Hex Value     Effect
    --------------------------------------------------------
     ROCKET          0x00000001    Rocket trail
     GRENADE         0x00000002    Grenade trail
     FLIES           0x00000004    Swarm of flies
     BFG             0x00000008    BFG particle swarm
     REDFOUNTAIN     0x00010000    Red fountain
     GREENFOUNTAIN   0x00020000    Green fountain
     BLUEFOUNTAIN    0x00030000    Blue fountain
     YELLOWFOUNTAIN  0x00040000    Yellow fountain
     PURPLEFOUNTAIN  0x00050000    Purple fountain
     BLACKFOUNTAIN   0x00060000    Black fountain
     WHITEFOUNTAIN   0x00070000    White fountain
    --------------------------------------------------------
    </pre>
    Note that the fountain flag values cannot be combined with each other. Doing so will
    simply result in another one of the existing fountain colors.
    <br><br>
    Examples:
    <pre>
    # a single effect
    particlefx = ROCKET
    
    # multiple effects
    particlefx = BFG|GREENFOUNTAIN
    
    # if there are spaces or disallowed characters, you must use quotations
    particlefx = "BFG + GREENFOUNTAIN"
    </pre>
<li><b>droptype</b><br>
    Default = NONE<br>
    This field allows the type of thing that is dropped by this thing when it dies to be
    edited. This field should either be a valid thing type mnemonic, or the special value
    NONE.
<li><b>mod</b><br>
    Default = 0<br>
    Special Means of Death flag for this thing type. Currently supported values are as follows:
    <pre>
    Unknown     0
    Fist        1
    Pistol      2
    Shotgun     3
    Chaingun    4
    Rocket      5
    R_Splash    6
    Plasma      7
    BFG         8
    BFG_Splash  9
    Chainsaw    10
    SSG         11
    Slime       12
    Lava        13
    Crush       14
    Telefrag    15
    Falling     16
    Suicide     17
    Barrel      18
    Splash      19
    Hit         20
    BFG11K      21
    BetaBFG     22
    BFGBurst    23
    PlayerMisc  24
    Grenade     25
    </pre>
    Specifying this field is not necessary for most thing types. It IS highly useful for controlling
    the obituaries triggered by player projectiles, however. Some of the values above are not
    fully supported yet.
<li><b>obituary_normal</b><br>
    Default = empty<br>
    Defines the obituary seen by players when killed by a projectile or other miscellaneous
    attack by a monster. If the obituary is not defined for this type, it will simply read that
    the player died. Note that you are only allowed to specify an obituary starting immediately
    after the player's name. If you want an obituary to say "Player was flamed",
    then simply make the obituary read "was flamed".
<li><b>obituary_melee</b><br>
    Default = empty<br>
    Defines the obituary seen by players when killed by a monster's melee attack.
    If the obituary is not defined for this type, it will simply read that the player died. Note 
    that you are only allowed to specify an obituary starting immediately after the player's 
    name. If you want an obituary to say "Player was stabbed mercilessly", then simply make the 
    obituary read "was stabbed mercilessly".
<li><b>translation</b><br>
    Default = 0<br>
    Sets a translation for the thing's sprite. Translation tables are 256-byte lumps which can
    be used to remap any range of colors in a sprite. When this field defaults, no translation
    will be used. Otherwise, you may either provide a number to access one of the internal
    player translation tables, or you may provide the name of a translation lump, which must
    be found between T_START and T_END markers amongst one of the currently loaded wad files.
    Numeric values for player translations are as follows. All of the player translations
    remap the pure green range.
    <pre>
    Number     Color
    ------------------
     1        Indigo
     2        Brown
     3        Red
     4        Tomato
     5        Dirt
     6        Blue
     7        Gold
     8        Felt
     9        Black
     10       Purple
     11       "Vomit"
     12       Pink
     13       Cream
     14       Yellow
    ------------------
    </pre>    
<li><b>dehackednum</b><br>
    Default = -1<br>
    As explained above, this is the number which must be used to refer to this thing type in
    DeHackEd patches. -1 means that the thing type is not accessible from DeHackEd, or by 
    parameterized codepointers that require a thing type DeHackEd number. User-defined thing
    types should currently only use DeHackEd numbers between 10000 and 32768, or simply use 
    -1 if no DeHackEd functionality is required. This number must be unique unless it is -1.
</ul>

Restrictions and Caveats:
<ul>
<li> At least two thing types must be defined (Unknown and DoomPlayer).
<li> The Unknown thing type must be defined.
<li> The DoomPlayer thing type must currently be defined (subject to change).
<li> All thing types must have a unique mnemonic no longer than 40 characters. They should only 
     contain alphanumeric characters and underscores. All other punctuation marks are explicity 
     reserved for extended syntactical use. Length will be verified, but format will not 
     (non-unique mnemonics will overwrite previous definitions, see below).
<li> All thing types with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     This will be verified.
</ul>

Replacing Existing Thing Types:
<br><br>
To replace the values of an existing thing type, simply define a new thing type with the exact 
same mnemonic value (as stated above, all thing types need a unique mnemonic, so duplicate 
mnemonics serve to indicate that an existing thing type should be replaced).
<br><br>
EDF 1.1 also adds delta structures, which allow fields of existing things to be edited
without replacing all values in those things. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# define a new thing type
thingtype ScarletPimpernel
{
  doomednum = 15000
  spawnstate = S_SCARPIMP1
  flags = SPECIAL|NOTDMATCH
  dehackednum = 10000
}

# overwrite an existing thing type (assume BaronOfHell is already defined normally...)
# everything is the same as the original except the fields I changed...
thingtype BaronOfHell
{
  doomednum = 3003
  spawnstate = S_BOSS_STND
  seestate = S_BOSS_RUN1
  seesound = brssit
  painstate = S_BOSS_PAIN
  painchance = 10                  # changed from 50 to 10
  painsound = dmpain
  meleestate = S_BOSS_ATK1
  missilestate = S_BOSS_ATK1
  deathstate = S_BOSS_DIE1
  deathsound = brsdth
  speed = 12                       # changed to from 8 to 12
  radius = 24.0000
  height = 64.0000
  mass = 1000
  activesound = dmact
  flags = SOLID|SHOOTABLE|COUNTKILL
  flags2 = E1M8BOSS|FOOTCLIP
  raisestate = S_BOSS_RAISE1
  obituary_normal = "was burned by a baron"
  obituary_melee  = "was ripped open by a baron"
  dehackednum = 16
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="inherit">
<hr>
<b>Thing Type Inheritance</b>
<hr>
</a>
<br>
New to EDF 1.2, thing type inheritance allows you to derive new thing types from existing
ones, so that there is no need to duplicate all the fields in the original type. To activate
inheritance for a thing type, use the following syntax:
<pre>
thingtype &lt;unique mnemonic&gt;
{
   inherits = &lt;thing type mnemonic&gt;
   &lt;any other thingtype fields&gt;
}
</pre>

When the <b>inherits</b> field is set in a thing type, its parent type will be processed first
if it has not already been processed. Then, all the fields from the parent type, except for
<b>dehackednum</b> and <b>doomednum</b>, will be copied from the parent type to this type. Once 
the parent is copied, any other fields in this type will be treated as a <b>thingdelta</b> section, 
such that only fields explicitly provided will overwrite values of the parent thing type.  
Defaults will not be applied for unlisted fields, again with the exceptions of <b>dehackednum</b>
and <b>doomednum</b>.
<br><br>
Thing delta sections are applied to thing types after initial processing is finished, and thus
do not affect the inheritance process. If a thing delta section is applied to a parent type, it
will not affect the child type.  Thing deltas applied to child types apply after both inheritance
and any values overridden in the child type.
<br><br>
Restrictions and Caveats:
<ul>
<li> A thing type may not inherit from itself, or from other thing types in a cycle. Circular
     inheritance errors will be caught by the processor and an error will occur, although
     possibly not during processing of the first inheriting type (the error may be found while
     processing a parent type).
<li> Only one thing type may be inherited from by each thing type, so there is no concept of
     multiple inheritance. However, there is no limit to the number of levels of inheritance
     other than the number of existing thing types, so each parent thing type may have its
     own parent, excepting the ultimate parent in an inheritance tree.
</ul>

Inheritance Example:
<pre>
/*
   As you can see here, thing type inheritance allows inheriting type 
   definitions to be minimized to only those fields which must differ. 
   In this example, the dehackednum of the new thing type will be -1, 
   since it is unspecified. The doomednum will be 20001, since it is 
   not inherited, but is specified in the child type. Remember that the 
   dehackednum and doomednum fields are NOT copied between thing types.
*/

thingtype MyNewBaron
{
   inherits     = BaronOfHell   # Inherit from the BaronOfHell
   doomednum    = 20001         # Set the doomednum to something meaningful
   translucency = 32768         # Make it 50% translucent                                
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="cast">
<hr>
<b>DOOM II Cast Call</b>
<hr>
</a>
<br>
The cast call structure allows you to edit and extend the DOOM II cast call used after
beating the game in DOOM II. Editing existing thing types via EDF or DeHackEd can otherwise
cause this part of the game to malfunction, and it has never before been possible to add your
own monsters into the fray. Now this can be done.
<br><br>
Unlike most other EDF sections, <b>castinfo</b> sections will be kept in the order they are 
specified, unless the <b>castorder</b> array is defined. The <b>castorder</b> array feature 
allows you to explicitly specify a complete ordering for the <b>castinfo</b> sections which 
overrides the order of their definitions. See below for more information on <b>castorder</b>.
<br><br>
Beginning with EDF 1.1, all <b>castinfo</b> sections are required to have a unique mnemonic. 
Sections with duplicate mnemonics will overwrite, with the last one occuring during parsing 
taking precedence as the definition.
<br><br>
Syntax:
<pre>
castinfo &lt;mnemonic&gt;
{
   type       = &lt;thing type mnemonic&gt;
   name       = &lt;string&gt;
   stopattack = &lt;boolean&gt;
   
   # see notes about this; there can be from zero to four sound blocks
   sound
   { 
      frame = &lt;frame mnemonic&gt;
      sfx   = &lt;sound mnemonic&gt;
   }
}
</pre>

Explanation of Fields:
<ul>
<li><b>type</b><br>
    Default = No default; this field is required.<br>
    This field must be set to a valid thing type mnemonic. This denotes which thing type is
    displayed at this entry's position in the cast call. As of EDF 1.2, if this type is not
    valid, the thing type "Unknown" will be substituted. This may cause the cast call to
    malfunction, however. The previous behavior was to cause an error.
<li><b>name</b><br>
    Default = See below.<br>
    This is an optional field that allows providing a name to display on the screen for the
    thing type. Note that if this field is not present in any of the first 17 definitions, 
    those cast members will use the normal default names from the executable, which are
    editable via BEX string replacement. If cast members beyond the first 17 have no name
    provided, they will say "unknown" (so you should always provide it in those cases).
<li><b>stopattack</b><br>
    Default = false<br>
    This is a special boolean value (can be any of yes/no, on/off, or true/false) which makes
    the thing break out of its attack frame cycle after its initial frame. This is only used
    by the player type by default, but could be used by any other type as well.
<li><b>sound</b><br>
    There can be up to four of these special blocks defined within each cast member. They
    define a sound event, so that whenever the thing type enters the designated frame, it will
    play the designated sound. If there are less than four definitions, the unused ones will
    be zeroed out. If there are more than four, any beyond four are simply ignored. Also, if
    the values provided to the fields in this block are invalid, they are simply ignored.<br>
    Explanation of Inner Fields:
    <ul>
    <li><b>frame</b><br>
        Default = S_NULL<br>
        Name of the frame this event should occur on
    <li><b>sfx</b><br>
        Default = none<br>
        Name of the sound to play when this event occurs.
    </ul>
</ul>

Restrictions and Caveats:
<ul>
<li> The castorder list is NOT required.
<li> At least one cast member must be defined.
<li> All cast members must have a unique mnemonic. Mnemonics should only contain alphanumeric 
     characters and underscores. All other punctuation marks are explicity reserved for 
     extended syntactical use. Format will not be verified. Non-unique mnemonics will overwrite 
     previous definitions, see below.
</ul>

Full Example:
<pre>
# My New Cast Call -- Only The Ultimate FooBar and the Player are worthy!
castinfo foobar
{
   type = FooBar
   name = "The Ultimate FooBar"
   
   sound { frame = S_FOOBAR_ATK1; sfx = firsht }
   sound { frame = S_FOOBAR_ATK3; sfx = firsht }
   sound { frame = S_FOOBAR_ATK5; sfx = firsht }
}

# Notice since DoomPlayer is now #2 and not #17, I still need to set his
# name, otherwise it would call him a former sergeant o_O
castinfo player
{
   type = DoomPlayer
   name = "Our Hero"
   stopattack = true
}
</pre>

Using the <b>castorder</b> Array
<br><br>
When editing the cast call, it will probably be advantageous to specify the <b>castorder</b> 
array. Doing so will allow you to avoid the EDF 1.0 problem of being forced to redefine the 
entire cast call simply to add a new cast member in the middle. It also allows you to move 
around existing <b>castinfo</b> definitions without editing them, and to omit or repeat
definitions.
<br><br>
Syntax:
<pre>
castorder = { &lt;mnemonic&gt;, ... }
</pre>

All mnemonics specified in the <b>castorder</b> list must be valid. If any do not exist, 
an error will occur.
<br><br>
As with other EDF lists, if the list is defined more than once, the latest definition
encountered is the one used. Also, you may use addition lists to add entries to the end of
the <b>castorder</b> list.
<br><br>
Full Example:
<pre>
# I decided to switch the cast call order around
castorder = { player, foobar }

...

# Later on, perhaps in another file, I add a new castinfo. I can do this:
castinfo weirdo
{
   type = WeirdoGuy
   name = "The Weirdo Guy"
}

# This will add weirdo to the end of the existing castorder list.
# I could also just redefine the entire list, but there's no point in this case.
castorder += { weirdo }
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="boss">
<hr>
<b>DOOM II Boss Brain Types</b>
<hr>
</a>
<br>
The Boss Brain thing types list allows editing of the types of monsters which can be spawned
by the DOOM II Boss Brain cube spitter object. This structure is a simple list of thing
type mnemonics, which are kept in the order they are provided. You can redefine the list at will, 
just as with the <b>spritenames</b> list.
<br><br>
Starting with EDF 1.1, there is no longer an 11-type limitation on the boss spawner list.
However, if you provide more than 11 thing types in this list, you must also define the new
<b>boss_spawner_probs</b> list, which must be a list of numbers which together equal 256. These
numbers serve as the probability values out of 256 for the corresponding thing types. If exactly 
11 types are defined and the <b>boss_spawner_probs</b> list is not defined, the normal defaults
will be used. If boss_spawner_probs is defined, it MUST be the exact same length as the
boss_spawner_types list.
<br><br>
Starting with EDF 1.2, if a thing type in the <b>boss_spawner_types</b> list is invalid, the
"Unknown" thing type will be substituted for it. The previous behavior was to cause an error.
<br><br>
Syntax:
<pre>
# A list of thing types

boss_spawner_types =
{
   &lt;thing type mnemonic&gt;, ...
}

# A list of probabilities for the above thing types. If provided, this list
# must be the same length as the above, and if not provided, the above list
# must contain exactly 11 types. The numbers in this list must add up to 256.

boss_spawner_probs =
{
   &lt;number&gt;, ...  
}
</pre>

Full Example:
<pre>
# Changed DoomImp to FooBar, and Archvile to the ScarletPimpernel
# (so it can give you a powerup, but not very often, since Archvile is the
#  rarest type ;)
# In a TC you might want to change ALL the monster types...
# These will use the default probabilities listed below, unless a
# boss_spawner_probs list is also defined somewhere.

boss_spawner_types =
{
   FooBar, Demon, Spectre, PainElemental, Cacodemon, ScarletPimpernel,
   Revenant, Arachnotron, Mancubus, HellKnight, BaronOfHell
}
</pre>

Example with More than 11 Thing Types:
<pre>
boss_spawner_types =
{
   DoomImp, Demon, Spectre, PainElemental, Cacodemon, Archvile, Revenant,
   Arachnotron, Mancubus, HellKnight, BaronOfHell, FooBar, ScarletPimpernel
}

boss_spawner_probs =
{
   40, 40, 30, 10, 30, 2, 10, 20, 30, 22, 10, 10, 2
}
</pre>

Normal Default Probabilities Used When 11 Types are Defined:
<pre>
boss_spawner_probs =
{
# prob. / thing type normally in this position in the list
   50,  # DoomImp
   40,  # Demon
   30,  # Spectre
   10,  # PainElemental
   30,  # Cacodemon
   2,   # Archvile
   10,  # Revenant
   20,  # Arachnotron
   30,  # Mancubus
   24,  # HellKnight
   10   # BaronOfHell
}
</pre>

<a href="#contents">Return to Table of Contents</a>

<p>
<a name="sound">
<hr>
<b>Sounds</b>
<hr>
</a>
<br>
New to EDF 1.1, sound definitions allow editing of existing sounds, as well as the addition of 
new sounds which can be referred to by things and frames. Although Eternity already supports the 
implicit addition of new sounds whose lumps start with the DS prefix, those sounds are only 
available to MapInfo and scripting. Since EDF allows the assignment of DeHackEd numbers, it 
allows much greater flexibility for new sounds.
<br><br>
EDF also provides access to some sound structure fields which are not currently supported
in DeHackEd.
<br><br>
Each sound must be given a unique mnemonic in its definition's header, and this is the name
used to identify the sound elsewhere. Each field in the sound definition is optional. If a 
field is not provided, it takes on the default value indicated below the syntax
information. Fields may also be provided in any order.
<br><br>
Syntax:
<pre>
sound &lt;mnemonic&gt;
{
   lump = &lt;string&gt;
   prefix = &lt;boolean&gt;
   singularity = &lt;singularity class&gt;
   priority = &lt;number&gt;
   link = &lt;sound mnemonic&gt;
   linkvol = &lt;number&gt;
   linkpitch = &lt;number&gt;
   skinindex = &lt;skin index type&gt;
   dehackednum = &lt;number&gt;
}
</pre>
Explanation of Fields:
<ul>
<li><b>lump</b><br>
    Default: If not provided, the mnemonic will be copied directly to the lump name. For example,
    if the mnemonic for an entry is dsfoo and the lump name is not provided, it will become
    dsfoo, and in that case, the prefix field (explained below) should be set to false.<br>
    The lump field indicates the lump name that this sound resource will have in WAD files.
    If the prefix field below is true, the prefix "DS" will be appended to this name when looking
    for the sound. Otherwise, this name will be used exactly as it is provided. In the event a
    sound is not found, a default sound for the current game mode (DSPISTOL in DOOM, GLDHIT in
    Heretic) will be played instead.
<li><b>prefix</b><br>
    Default = true<br>
    This boolean field indicates whether to prefix the lump name with DS when searching for
    this sound's lump. Values of false/no/off mean that the lump will not be prefixed. Values
    of true/yes/on mean that it should be prefixed. 
<li><b>singularity</b><br>
    Default = sg_none<br>
    This field indicates a singularity class for this sound. If another sound of the same
    singularity class is playing when this sound is played, the former will be stopped. This is
    used to implement appropriate player sound behavior in an extensible and modifiable manner.
    The possible values for the singularity class are as follows:
    <pre>
    sg_none
    sg_itemup
    sg_wpnup
    sg_oof
    sg_getpow</pre>
<li><b>priority</b><br>
    Default = 64<br>
    This field establishes a relative priority for this sound. When sounds must be stopped in
    order to start new ones, those with the lowest priority will be replaced first.
<li><b>link</b><br>
    Default = "none"<br>
    This field links this sound definition to another existing sound definition. Its value must
    either be "none," or another valid sound mnemonic. When a linked sound is played, the sound
    that is linked to will be played instead, using the linkvol and linkpitch parameters provided
    in this sound entry. Use of this feature will rarely be necessary.
<li><b>linkvol</b><br>
    Default = -1<br>
    This field provides a value to be added to the sound's volume when a linked sound is played
    through this sound definition.
<li><b>linkpitch</b><br>
    Default = -1<br>
    This field provides a pitch value to be used when a linked sound is played through this
    sound definition.
<li><b>skinindex</b><br>
    Default = sk_none<br>
    This field indicates a player skin sound index for this sound. If the player object plays
    this sound, it will become subject to remapping through the player's skin. The following
    values are possible for skin index, and each corresponds to one of the fields in the
    Legacy skin format:  <!-- TODO: add link to new skin format documentation! -->
    <pre>
    sk_none
    sk_plpain
    sk_pdiehi
    sk_oof
    sk_slop
    sk_punch
    sk_radio
    sk_pldeth
    sk_plfall
    sk_plfeet
    sk_fallht</pre>    
<li><b>dehackednum</b><br>
    Default = -1<br>
    In order to be accessible to thing and frame definitions, a sound definition must be given
    a unique DeHackEd number. The value zero is reserved and cannot be used. In order to avoid
    conflict, and to remain compatible with future versions of the Eternity Engine, user sounds
    should either use DeHackEd numbers between 10000 and 32768, or simply use the value -1 if
    no thing/frame or DeHackEd access is necessary. Note that if a thing or frame later attempts
    to use a sound with no unique DeHackEd number via its mnemonic, a warning will be printed
    to the verbose EDF log, and the sound field in question will be set to "none".
</ul>

Restrictions and Caveats:
<ul>
<li> All sounds must have a unique mnemonic no longer than 16 characters. They should only 
     contain alphanumeric characters and underscores. Length will be verified, but format will 
     not (non-unique mnemonics will overwrite previous definitions, see below). The mnemonic
     "none" is reserved and cannot be overridden or edited. Sounds using the mnemonic "none"
     will not be playable.
<li> If the lump name is not provided, so that the mnemonic will be copied to it, then the
     mnemonic must also either be a full, valid lump name, or a string that becomes one if
     the prefix field is set to true. If a mnemonic is used which is not a valid sound lump
     name, but no lump name is provided, then the sound entry will not be able to play, and
     the default sound for the game mode will play instead.
<li> All sounds with a DeHackEd number not equal to -1 must have a unique DeHackEd number.
     Any sounds with a non-unique DeHackEd number will be inaccessible to things, frames, and
     editing via DeHackEd. Such sounds may still be referenced via their mnemonic in scripts
     and MapInfo, however. The DeHackEd number 0 (zero) is reserved for sounds and cannot be
     used in an EDF sound definition.
</ul>

Replacing Existing Sounds:
<br><br>
To replace the values of an existing EDF sound definition, simply define a new sound 
with the exact same mnemonic value (as stated above, all sounds need a unique mnemonic, so 
duplicate mnemonics serve to indicate that an existing sound should be replaced).
<br><br>
EDF 1.1 adds delta structures, which allow fields of existing sounds to be edited
without replacing all values in those sounds. Delta structures also cascade, and are thus
useful for layering of different modifications. See the section 
<a href="#delta">Delta Structures</a> for full information.
<br><br>
Full Example:
<pre>
# Define some new sounds
# This one is only accessible via scripting because it doesn't have a DeHackEd number.
sound MySound
{
   lump = foo  # this will play DSFOO, since prefix defaults to true
}

# This entry uses its mnemonic to double as the sound lump name.
sound dsblah
{
   prefix = false  # Without this, it would try to play DSDSBLAH, which is wrong
   dehackednum = 10000
}

# This entry also uses the mnemonic as the sound name, but with prefixing.
# Since prefix defaults to true, the sound lump played will be "DSEXPLOD".
sound explod
{
   priority = 128
   dehackednum = 10001
}

# This entry links to another sound.
sound BlahLink
{
   lump = dummy    # this won't even get used in this case
   prefix = false  # dsblah doesn't need a prefix, so we should echo that here
   link = dsblah   # we've linked this entry to the dsblah sound
   linkvol = 150   # use some suitable values for these (must experiment)
   linkpitch = 0
   dehackednum = 10002
}

# This entry overrides a previously defined sound.
sound explod
{
   priority = 96        # Maybe we like 96 better than 128...
   dehackednum = 10001  # We can reuse the same DeHackEd number, since it overwrites
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="delta">
<hr>
<b>Delta Structures</b>
<hr>
</a>
<br>
New to EDF 1.1, delta structures are an easier and more flexible way to edit existing thing 
type, frame, and sound definitions.
<br><br>
Each delta structure for a thing type, frame, or sound specifies by mnemonic the section that it
edits inside it. This allows for any number of delta structures to be defined. The structures
are always applied in the order in which they are encountered during parsing, so that, like
style sheets in HTML, delta structures cascade. This means you can load your own set of
delta structures on top of an existing set in a modification.
<br><br>
Delta Structure Syntax:
<pre>
# A delta structure for a frame has this syntax:
framedelta
{
   name = &lt;frame mnemonic&gt;
   &lt;list of frame fields&gt;
}

# A delta structure for a thing type has this syntax:
thingdelta
{
   name = &lt;thingtype mnemonic&gt;
   &lt;list of thingtype fields&gt;
}

# A delta structure for a sound has this syntax:
sounddelta
{
   name = &lt;sound mnemonic&gt;
   &lt;list of sound fields&gt;
}
</pre>

The name field is required, and must be set to a valid sound, frame, or thingtype mnemonic in 
order to specify the definition that the delta structure edits. Along with the name, the delta
structure can specify any field that is valid in that type of definition (see exceptions below). 
<br><br>
See the
<a href="#frames">Frames</a>, <a href="#things">Thing Types</a>, and
<a href="#sound">Sounds</a> sections for full information on their fields and syntax.
<br><br>
Any field not specified in a delta structure will not be affected, and retains the value that
it had before the delta structure was applied.  A delta structure must specify values
explicitly, even if the new values are the usual defaults for those fields. Note that the
frame args list must be completely specified. It is not possible to override only some of the
values in that list.
<br><br>
Fields not supported in delta structures:
<ul>
<li> The <b>dehackednum</b> field of any section edited by a delta structure cannot be changed.
     Although the field will be syntactically accepted by the parser, any value provided to it
     in a delta structure will have no effect. Only definition sections can provide a DeHackEd
     number.
<li> The <b>cmp</b> field of the <b>frame</b> block is not supported in <b>framedelta</b> sections.
<li> The <b>inherits</b> field of the <b>thingtype</b> block is not supported in <b>thingdelta</b> sections.
</ul>

Frame Delta Example:
<pre>
# Change the Zombieman attack frame to use the shotgun zombie attack
framedelta
{
   name = S_POSS_ATK2
   action = SPosAttack
}
</pre>
Thing Delta Example:
<pre>
# Change the Zombieman's drop type to MegaSphere, and his spawnhealth to 400
thingdelta
{
   name = Zombieman
   droptype = MegaSphere
   spawnhealth = 400
}


# Later on, maybe in a different file, we change the spawnhealth again
thingdelta
{
   name = Zombieman
   spawnhealth = 20
}

# At this point, the Zombieman drops MegaSpheres, but his spawnhealth is 20, not 400.
</pre>
Sound Delta Example:
<pre>
# This changes the sound explod we defined earlier
sounddelta
{
   name = explod
   priority = 200
   singularity = sg_getpow
}
</pre>
<a href="#contents">Return to Table of Contents</a>

<p>
<a name="misc">
<hr>
<b>Miscellaneous Settings</b>
<hr>
</a>
<br>
These optional settings allow customization of various game engine behaviors. When not
provided, they take on the indicated default values. All of these options can only be
specified in the topmost level of an EDF file. The last definition encountered is the
one which will be used.
<br><br>
<ul>
<li><b>doom2_title_tics</b><br>
    Default: 385 (11 seconds)<br>
    This variable allows you to change the length of time for which the DOOM II title screen
    is displayed. This is useful if your title song needs to be longer or shorter than the
    original. The unit for this variable is tics (35 per second).<br>
    Example:
    <pre>
    doom2_title_tics = 525    # make the DOOM II title screen last 15 seconds
    </pre>
</ul>
<a href="#contents">Return to Table of Contents</a>

</body>
</html>







